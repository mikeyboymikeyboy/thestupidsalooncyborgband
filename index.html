<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>The Stupid Saloon Cyborg Band</title>
    <link href="https://fonts.googleapis.com/css2?family=IM+Fell+English&display=swap" rel="stylesheet">
    <style>
        @font-face {
            font-family: 'IM Fell English';
            src: url('IMFellEnglish.woff2') format('woff2');
            font-weight: normal;
            font-style: normal;
        }

        body,
        #text,
        button,
        .prompt,
        .option,
        .title {
            font-family: 'IM Fell English', serif !important;
        }

        body {
            font-family: "IM Fell English", serif;
            background: black;
            color: white;
            text-align: center;
            padding: 2em;
            font-size: 1.5em;
        }

        img {
            max-width: 90%;
            height: auto;
            margin-bottom: 1em;
        }

        .button {
            display: inline-block;
            background: linear-gradient(to bottom, #3e2f23, #2a1f16);
            border: 1px solid #a57c57;
            border-radius: 4px;
            color: #f4e7d0;
            font-family: 'IM Fell English', serif;
            letter-spacing: 0.5px;
            padding: 10px 16px;
            margin: 1em;
            cursor: pointer;
            box-shadow: inset 0 0 4px #00000088, 0 0 6px #3defff44;
            transition: all 0.2s ease-in-out;
            font-size: 1em;
        }

        .button:hover {
            background: #4c372a;
            border-color: #ffc56f;
            box-shadow: inset 0 0 6px #000000aa, 0 0 10px #00ffe655;
            transform: translateY(-1px);
        }

        .button:active {
            transform: scale(0.97);
            box-shadow: inset 0 0 3px #000000cc, 0 0 4px #ffaa0088;
        }

        .button.waiting {
            animation: pulse 1.2s ease-in-out infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 6px #3defff33;
                background-color: #3e2f23;
            }
            50% {
                box-shadow: 0 0 20px #3defffbb;
                background-color: #4c372a;
            }
            100% {
                box-shadow: 0 0 6px #3defff33;
                background-color: #3e2f23;
            }
        }
    
        .image-text-container {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            gap: 2em;
            margin-bottom: 1.5em;
            flex-wrap: wrap;
        }
        .image-text-container img {
            max-width: 100%;
            height: auto;
        }
        .text-block {
            max-width: 600px;
            text-align: left;
        }

        @media (max-width: 768px) {
            .image-text-container {
                flex-direction: column;
                align-items: center;
            }
            .text-block {
                text-align: center;
            }
        }

        @media (max-width: 768px) {
            body {
                font-size: 1.875em;
            }
            .image-text-container {
                flex-direction: column;
                align-items: center;
                gap: 2.5em;
            }
            .text-block {
                text-align: center;
            }
            .button {
                padding: 12px 20px;
                font-size: 1.25em;
            }
        }

        .fade-in {
            opacity: 0;
            transition: opacity 0.8s ease-in;
        }
        .fade-in.loaded {
            opacity: 0.4;
        }

        .scrolling-container {
            height: 300px;
            overflow: hidden;
            position: relative;
            width: 100%;
            margin: 2em auto;
        }

        .scrolling-inner {
            position: relative;
            text-align: center;
            white-space: pre-line;
        }

        .scrolling-preview {
            position: absolute;
            left: 10px;
            z-index: 5;
            pointer-events: none;
        }

        .scrolling-preview img {
            max-height: 200px;
            border: 2px solid red;
            opacity: 0.4;
        }

        .slideshow-container {
            position: fixed;
            max-height: 400px;
            width: 400px;
            pointer-events: none;
            z-index: 0;
            animation: floatUp 6s ease-in-out infinite alternate;
        }

        .slideshow-container.left-fixed {
            left: 60px;
        }

        .slideshow-container.right {
            right: 60px;
        }

        .slideshow-image {
            max-height: 400px;
            width: auto;
            opacity: 0;
            transition: opacity 4s ease-in-out;
        }

        .slideshow-image.visible {
            opacity: 0.4;
        }

        @keyframes floatUp {
            0% { transform: translateY(0); }
            100% { transform: translateY(-20px); }
        }

        @keyframes floatDown {
            0% { transform: translateY(0); }
            100% { transform: translateY(20px); }
        }

        @keyframes floatLeft {
            0% { transform: translateX(0); }
            100% { transform: translateX(-20px); }
        }

        @keyframes floatRight {
            0% { transform: translateX(0); }
            100% { transform: translateX(20px); }
        }

        @keyframes floatDiagonalLeft {
            0% { transform: translate(0, 0); }
            100% { transform: translate(-20px, -20px); }
        }

        @keyframes floatDiagonalRight {
            0% { transform: translate(0, 0); }
            100% { transform: translate(20px, -20px); }
        }

        .floatUp         { animation: floatUp 6s ease-in-out infinite alternate; }
        .floatDown       { animation: floatDown 6s ease-in-out infinite alternate; }
        .floatLeft       { animation: floatLeft 6s ease-in-out infinite alternate; }
        .floatRight      { animation: floatRight 6s ease-in-out infinite alternate; }
        .floatDiagonalLeft  { animation: floatDiagonalLeft 6s ease-in-out infinite alternate; }
        .floatDiagonalRight { animation: floatDiagonalRight 6s ease-in-out infinite alternate; }

        .comic-download, .sonic-download {
            margin-top: 2em;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            0% { box-shadow: 0 0 5px #3defff55; }
            100% { box-shadow: 0 0 20px #3defffaa; }
        }

        .comic-text-input {
            font-family: 'IM Fell English', serif;
            width: 100%;
            height: 60px;
            margin-top: 5px;
            padding: 5px;
            background-color: #f9f6ef;
            border: 1px solid #aaa;
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.1);
            font-size: 0.9em;
        }

        .comic-text {
            font-family: 'IM Fell English', serif;
            font-size: 24px;
            fill: white;
            text-anchor: middle;
            dominant-baseline: middle;
            text-shadow: 2px 2px 2px rgba(0,0,0,0.8);
        }

        .text-bg {
            fill: rgba(0,0,0,0.6);
            rx: 8;
            ry: 8;
        }

        .text-container {
            transform-box: fill-box;
            transform-origin: center;
        }
    </style>
</head>
<body>
    <div id="game">
        <p>Loading story...</p>
    </div>
    
    <canvas id="comicCanvas" style="display: none;"></canvas>
    
    <script src="https://unpkg.com/pdf-lib"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvg@3.0.10/lib/umd.min.js"></script>

    <div id="comicSvgWrapper" style="display: none;">
        <svg viewBox="0 0 2048 2860" width="1024" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <pattern id="inkTexture" patternUnits="userSpaceOnUse" width="6" height="6">
                    <path d="M0,0 L6,6 M6,0 L0,6" stroke="#111" stroke-width="0.5"/>
                </pattern>

                <clipPath id="panel1"><polygon points="17,1079 17,639 18,254 497,252 537,252 538,253 541,259 601,381 808,802 926,1042 942,1075 942,1079"/></clipPath>
                <clipPath id="panel2"><polygon points="582,252 793,252 2046,253 2046,281 2044,1066 2043,1077 1947,1078 1712,1079 1208,1080 986,1080 962,1032 756,613 609,314 582,259"/></clipPath>
                <clipPath id="panel3"><polygon points="1871,1120 2044,1120 2044,1962 1787,1992 1744,1997 1390,2038 1295,2049 1269,2052 1261,2052 1261,2050 1266,1225 1267,1124 1268,1123"/></clipPath>
                <clipPath id="panel4"><polygon points="19,2197 19,2075 20,1123 1221,1121 1221,1203 1217,1935 1216,2055 965,2085 898,2093 40,2195 23,2197"/></clipPath>
                <clipPath id="panel5"><polygon points="18,2859 18,2239 1233,2099 1390,2081 1643,2052 1992,2012 2027,2008 2036,2007 2044,2007 2044,2859"/></clipPath>
            </defs>

            <image x="-76" y="169" width="1110" height="992" clip-path="url(#panel1)" preserveAspectRatio="xMidYMid slice" crossorigin="anonymous" />
            <image x="436" y="170" width="1756" height="993" clip-path="url(#panel2)" preserveAspectRatio="xMidYMid slice" crossorigin="anonymous" />
            <image x="1183" y="1027" width="939" height="1118" clip-path="url(#panel3)" preserveAspectRatio="xMidYMid slice" crossorigin="anonymous" />
            <image x="-101" y="1014" width="1442" height="1291" clip-path="url(#panel4)" preserveAspectRatio="xMidYMid slice" crossorigin="anonymous" />
            <image x="-184" y="1922" width="2431" height="1022" clip-path="url(#panel5)" preserveAspectRatio="xMidYMid slice" crossorigin="anonymous" />

            <g class="text-container" transform="translate(400, 1000)">
                <rect class="text-bg" x="-200" y="-40" width="400" height="80" />
                <text class="comic-text" x="0" y="0"></text>
            </g>
            <g class="text-container" transform="translate(1200, 1000)">
                <rect class="text-bg" x="-200" y="-40" width="400" height="80" />
                <text class="comic-text" x="0" y="0"></text>
            </g>
            <g class="text-container" transform="translate(1600, 1800)">
                <rect class="text-bg" x="-200" y="-40" width="400" height="80" />
                <text class="comic-text" x="0" y="0"></text>
            </g>
            <g class="text-container" transform="translate(500, 1800)">
                <rect class="text-bg" x="-200" y="-40" width="400" height="80" />
                <text class="comic-text" x="0" y="0"></text>
            </g>
            <g class="text-container" transform="translate(1024, 2700)">
                <rect class="text-bg" x="-200" y="-40" width="400" height="80" />
                <text class="comic-text" x="0" y="0"></text>
            </g>

            <g class="panel-shadow" fill="url(#inkTexture)" stroke="black" stroke-width="15">
                <polygon points="17,1079 17,639 18,254 497,252 537,252 538,253 541,259 601,381 808,802 926,1042 942,1075 942,1079"/>
                <polygon points="582,252 793,252 2046,253 2046,281 2044,1066 2043,1077 1947,1078 1712,1079 1208,1080 986,1080 962,1032 756,613 609,314 582,259"/>
                <polygon points="1871,1120 2044,1120 2044,1962 1787,1992 1744,1997 1390,2038 1295,2049 1269,2052 1261,2052 1261,2050 1266,1225 1267,1124 1268,1123"/>
                <polygon points="19,2197 19,2075 20,1123 1221,1121 1221,1203 1217,1935 1216,2055 965,2085 898,2093 40,2195 23,2197"/>
                <polygon points="18,2859 18,2239 1233,2099 1390,2081 1643,2052 1992,2012 2027,2008 2036,2007 2044,2007 2044,2859"/>
            </g>
        </svg>
    </div>

    <script>
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let buffers = {};
        let currentSource = null;
        let choiceMade = null;
        let isLoopingScene = false;
        let currentScene = null;
        let storyData = [];
        let visitedImages = [];
        let visitedTexts = [];
        let visitedAudio = [];
        let imageCache = new Map();

        async function loadImageAsBlob(url) {
            if (imageCache.has(url)) {
                return imageCache.get(url);
            }

            try {
                const response = await fetch(url, {
                    mode: 'cors',
                    credentials: 'omit'
                });
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const blob = await response.blob();
                const blobUrl = URL.createObjectURL(blob);
                
                const img = new Image();
                img.crossOrigin = "anonymous";
                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = reject;
                    img.src = blobUrl;
                });
                
                imageCache.set(url, blobUrl);
                return blobUrl;
            } catch (error) {
                console.error('Error loading image:', error);
                return null;
            }
        }

        function loadAudio(url) {
            return fetch(url)
                .then(res => res.arrayBuffer())
                .then(buf => audioContext.decodeAudioData(buf));
        }

        async function playAudio(name, loop, onEnded) {
            stopAudio();
            const buffer = buffers[name];
            if (!buffer) return;
            if (name) visitedAudio.push(name);
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(audioContext.destination);
            source.loop = loop;
            if (onEnded) {
                source.onended = () => {
                    document.querySelectorAll('.button.waiting').forEach(btn => {
                        btn.classList.remove('waiting');
                    });
                    onEnded();
                };
            }
            source.start(0);
            currentSource = source;
        }

        function stopAudio() {
            if (currentSource) {
                try {
                    currentSource.stop();
                } catch (e) {}
                currentSource.disconnect();
                currentSource = null;
                stopMultiAudio();
            }
        }

        async function showScene(sceneId) {
            const scene = storyData.find(s => s.id === sceneId || s.name === sceneId);
            if (!scene) {
                document.getElementById("game").innerHTML = `<p>‚ùå Scene not found: ${sceneId}</p>`;
                return;
            }
            currentScene = scene;
            if (scene.image && !visitedImages.includes(scene.image)) {
                visitedImages.push(scene.image);
                visitedTexts.push(scene.text.replace(/\[\[.*?\]\]/g, ''));
                await loadImageAsBlob(scene.image);
            }
            let html = '';
            
            if (scene.image || scene.text) {
                const cleanText = scene.text ? scene.text.replace(/\[\[.*?\]\]/g, '') : '';
                const isFinal = !scene.choices || scene.choices.length === 0;
                const imageUrl = scene.image ? await loadImageAsBlob(scene.image) : '';
                
                html += `
                    <div class="image-text-container">
                        ${imageUrl ? `<img src="${imageUrl}" alt="" class="fade-in" crossOrigin="anonymous" onload="this.classList.add('loaded')">` : ''}
                        <div class="text-block">
                            ${scene.scrollText === true
                                ? `<div class="scrolling-container">
                                    <div class="slideshow-container left-fixed"><img id="slideshowImage1" class="slideshow-image" crossOrigin="anonymous" src=""></div>
                                    <div class="slideshow-container right"><img id="slideshowImage2" class="slideshow-image" crossOrigin="anonymous" src=""></div>
                                    <div class="scrolling-inner">${cleanText}</div>
                                  </div>`
                                : cleanText}
                        </div>
                    </div>
                `;
            }

            if (scene.choices && scene.choices.length > 0) {
                scene.choices.forEach(choice => {
                    html += `<div class="button" onclick="handleChoice('${choice.next}')">${choice.label}</div>`;
                });
            } else {
                html += `
                    <div class="button comic-download" onclick="downloadComic()">üìÑ Download Your Adventure Comic</div>
                    <div class="button sonic-download" onclick="downloadSonicAdventure()">üéµ Download Your Sonic Adventure</div>
                `;
            }

            if (scene.multiAudio) {
                isLoopingScene = true;
                playMultiAudio(scene.multiAudio, () => {
                    if (choiceMade) {
                        showScene(choiceMade);
                        choiceMade = null;
                    }
                });
                const switcherButtons = Object.keys(scene.multiAudio).map(label =>
                    `<button class='button' onclick="switchToTrack('${label}')">Switch to ${label}</button>`
                ).join("");
                html += "<div style='margin-top:1em'>" + switcherButtons + "</div>";
            }

            document.getElementById("game").innerHTML = html;

            if (scene.scrollText === true) {
                const img1 = document.getElementById("slideshowImage1");
                const img2 = document.getElementById("slideshowImage2");
                if (visitedImages.length > 0 && img1 && img2) {
                    const floatClasses = ['floatUp', 'floatDown', 'floatLeft', 'floatRight', 'floatDiagonalLeft', 'floatDiagonalRight'];
                    function applyRandomFloatClass(img) {
                        floatClasses.forEach(cls => img.classList.remove(cls));
                        const randomClass = floatClasses[Math.floor(Math.random() * floatClasses.length)];
                        img.classList.add(randomClass);
                    }

                    function randomizePosition(container) {
                        const top = Math.floor(Math.random() * 70) + 10;
                        container.style.top = top + '%';
                    }

                    let slideshowIndex = 0;
                    setInterval(async () => {
                        const imageUrl = visitedImages[slideshowIndex % visitedImages.length];
                        const blobUrl = await loadImageAsBlob(imageUrl);
                        const isEven = slideshowIndex % 2 === 0;
                        if (isEven) {
                            img1.src = blobUrl;
                            applyRandomFloatClass(img1);
                            randomizePosition(img1.parentElement);
                            img1.classList.add("visible");
                            img2.classList.remove("visible");
                        } else {
                            img2.src = blobUrl;
                            applyRandomFloatClass(img2);
                            randomizePosition(img2.parentElement);
                            img2.classList.add("visible");
                            img1.classList.remove("visible");
                        }
                        slideshowIndex++;
                    }, 4000);
                }

                const container = document.querySelector('.scrolling-container');
                const inner = document.querySelector('.scrolling-inner');
                if (container && inner) {
                    const distance = inner.scrollHeight + container.clientHeight;
                    inner.style.transform = 'translateY(0px)';
                    inner.style.transition = `transform ${distance / 50}s linear`;
                    requestAnimationFrame(() => {
                        inner.style.transform = `translateY(-${distance}px)`;
                    });
                }
            }

            if (scene.audio) {
                isLoopingScene = scene.loopAudio;
                playAudio(scene.audio, scene.loopAudio, () => {
                    if (choiceMade) {
                        showScene(choiceMade);
                        choiceMade = null;
                    }
                });
            }
        }

        function handleChoice(nextId) {
            const selectedChoice = currentScene.choices.find(c => c.next === nextId);

            if (isLoopingScene) {
                choiceMade = nextId;

                const buttons = document.querySelectorAll(".button");
                buttons.forEach(btn => {
                    if (btn.textContent === selectedChoice?.label) {
                        btn.classList.add("waiting");
                    }
                });

                if (currentSource) {
                    currentSource.loop = false;
                    return;
                }

                if (currentMultiAudio) {
                    for (let label in multiAudioGains) {
                        multiAudioGains[label].gain.setTargetAtTime(0, audioContext.currentTime, 0.2);
                    }

                    setTimeout(() => {
                        stopMultiAudio();
                        showScene(choiceMade);
                        choiceMade = null;
                    }, 1000);

                    return;
                }
            }

            showScene(nextId);
        }

        async function preloadImages(imageUrls) {
            await Promise.all(imageUrls.map(loadImageAsBlob));
        }

        async function loadStory() {
            try {
                const res = await fetch("/story.json");
                if (!res.ok) {
                    throw new Error(`HTTP error! status: ${res.status}`);
                }
                storyData = await res.json();

                const imageUrls = storyData
                    .filter(scene => scene.image)
                    .map(scene => scene.image);
                await preloadImages(imageUrls);

                const urls = [];

                storyData.forEach(scene => {
                  if (scene.audio) urls.push(scene.audio);
                  if (scene.multiAudio) {
                    for (let key in scene.multiAudio) {
                      urls.push(scene.multiAudio[key]);
                    }
                  }
                });

                const uniqueUrls = [...new Set(urls)];
                for (let url of uniqueUrls) {
                    buffers[url] = await loadAudio(url);
                }

                const start = storyData.find(s => s.name === "START");

                const startText = (start?.text || 'Welcome adventurer...')
                    .replace(/\n/g, '<br />')
                    .replace(/\[\[.*?\]\]/g, '');

                const startImage = start?.image ? await loadImageAsBlob(start.image) : '';

                document.getElementById("game").innerHTML = `
                  <div class="image-text-container">
                    ${startImage ? `<img src="${startImage}" alt="" class="fade-in" crossOrigin="anonymous" onload="this.classList.add('loaded')">` : ''}
                    <div class="text-block">${startText}</div>
                  </div>
                  <div class="button" onclick="startScene()">BEGIN YOUR ADVENTURE</div>
                `;
            } catch (err) {
                document.getElementById("game").innerHTML = `<p>‚ùå Failed to load story.json<br />${err}</p>`;
                console.error(err);
            }
        }

        function startScene() {
            showScene("BEGIN YOUR ADVENTURE");
        }

        loadStory();
    
        let multiAudioSources = {};
        let multiAudioGains = {};
        let currentMultiAudio = null;

        async function playMultiAudio(multiAudioMap, onEnded) {
            stopAudio();
            stopMultiAudio();

            multiAudioSources = {};
            multiAudioGains = {};

            const labels = Object.keys(multiAudioMap || {});
            if (labels.length === 0) return;

            const now = audioContext.currentTime;
            const startTime = now;
            const promises = [];

            for (let label of labels) {
                const url = multiAudioMap[label];
                if (url) visitedAudio.push(url);
                const promise = loadAudio(url).then(buffer => {
                    const source = audioContext.createBufferSource();
                    source.buffer = buffer;
                    source.loop = true;

                    const gainNode = audioContext.createGain();
                    gainNode.gain.value = 0;

                    source.connect(gainNode).connect(audioContext.destination);
                    multiAudioSources[label] = source;
                    multiAudioGains[label] = gainNode;
                });
                promises.push(promise);
            }

            await Promise.all(promises);

            Object.values(multiAudioSources).forEach(src => src.start(0));
            currentMultiAudio = true;
            const firstTrack = Object.keys(multiAudioSources)[0];
            if (firstTrack) {
                multiAudioGains[firstTrack].gain.setValueAtTime(1, audioContext.currentTime);
            }

            if (onEnded) {
                Object.values(multiAudioSources).forEach(source => {
                    source.onended = onEnded;
                });
            }
        }

        function stopMultiAudio() {
            for (let label in multiAudioSources) {
                try { multiAudioSources[label].stop(); } catch (e) {}
                multiAudioSources[label].disconnect();
            }
            multiAudioSources = {};
            multiAudioGains = {};
            currentMultiAudio = null;
        }

        function switchToTrack(label) {
            if (!multiAudioGains[label]) return;
            for (let l in multiAudioGains) {
                multiAudioGains[l].gain.setTargetAtTime(l === label ? 1 : 0, audioContext.currentTime, 0.1);
            }
        }

        window.downloadComic = async function downloadComic() {
            console.log("Generating comic with images:", visitedImages);
            
            try {
                const journeyImages = visitedImages.slice(0, 5);
                const journeyTexts = visitedTexts.slice(0, 5);
                
                if (journeyImages.length === 0) {
                    alert("No images available from your journey. Try playing through the story first!");
                    return;
                }

                const blobUrls = await Promise.all(journeyImages.map(loadImageAsBlob));
                
                const svg = document.querySelector("#comicSvgWrapper svg");
                const panels = Array.from(svg.querySelectorAll("image"));
                const textElements = Array.from(svg.querySelectorAll(".comic-text"));
                
                panels.forEach(panel => panel.removeAttribute("href"));
                
                const panelOrder = [0, 1, 3, 2, 4];
                panelOrder.forEach((journeyIndex, panelIndex) => {
                    if (blobUrls[journeyIndex]) {
                        panels[panelIndex].setAttribute("href", blobUrls[journeyIndex]);
                    }
                    if (journeyTexts[journeyIndex]) {
                        const scene = storyData.find(s => s.text === journeyTexts[journeyIndex]);
                        let text = scene?.comicText || journeyTexts[journeyIndex].split('.')[0];
                        text = text.length > 50 ? text.substring(0, 47) + '...'  : text;
                        textElements[panelIndex].textContent = text;
                    }
                });

                const canvas = document.getElementById('comicCanvas');
                canvas.width = 2048;
                canvas.height = 2860;
                const ctx = canvas.getContext("2d");

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const v = await canvg.Canvg.fromString(ctx, svg.outerHTML);
                await v.render();

                const imgData = canvas.toDataURL("image/png");

                const pdfDoc = await PDFLib.PDFDocument.create();
                const img = await pdfDoc.embedPng(imgData);
                const pageWidth = 495;
                const page = pdfDoc.addPage([pageWidth, pageWidth * (canvas.height / canvas.width)]);

                page.drawImage(img, {
                    x: 0,
                    y: 0,
                    width: pageWidth,
                    height: pageWidth * (canvas.height / canvas.width)
                });

                const pdfBytes = await pdfDoc.save();
                const blob = new Blob([pdfBytes], { type: "application/pdf" });
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = "your-adventure-comic.pdf";
                link.click();
                
                URL.revokeObjectURL(link.href);
                blobUrls.forEach(url => URL.revokeObjectURL(url));
                
                console.log("Comic generated and downloaded successfully!");
            } catch (error) {
                console.error("Error generating comic:", error);
                alert("Sorry, there was an error generating your comic. Please try again.");
            }
        };

        window.downloadSonicAdventure = async function downloadSonicAdventure() {
            try {
                if (visitedAudio.length === 0) {
                    alert("No audio files to download. Try playing through the story first!");
                    return;
                }

                const totalLength = visitedAudio.reduce((acc, url) => {
                    const buffer = buffers[url];
                    return acc + (buffer ? buffer.length : 0);
                }, 0);

                const offlineContext = new OfflineAudioContext({
                    numberOfChannels: 2,
                    length: totalLength,
                    sampleRate: 44100
                });

                let currentTime = 0;
                for (const url of visitedAudio) {
                    const buffer = buffers[url];
                    if (!buffer) continue;

                    const source = offlineContext.createBufferSource();
                    source.buffer = buffer;
                    source.connect(offlineContext.destination);
                    source.start(currentTime);
                    currentTime += buffer.duration;
                }

                const renderedBuffer = await offlineContext.startRendering();
                const wavBlob = await audioBufferToWav(renderedBuffer);
                
                const link = document.createElement("a");
                link.href = URL.createObjectURL(wavBlob);
                link.download = "your-sonic-adventure.wav";
                link.click();
                URL.revokeObjectURL(link.href);
            } catch (error) {
                console.error("Error downloading audio:", error);
                alert("Sorry, there was an error downloading your sonic adventure. Please try again.");
            }
        };

        function audioBufferToWav(buffer) {
            const interleaved = new Float32Array(buffer.length * buffer.numberOfChannels);
            for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
                const channelData = buffer.getChannelData(channel);
                for (let i = 0; i < channelData.length; i++) {
                    interleaved[i * buffer.numberOfChannels + channel] = channelData[i];
                }
            }

            const dataView = encodeWAV(interleaved, buffer.numberOfChannels, buffer.sampleRate);
            return new Blob([dataView], { type: 'audio/wav' });
        }

        function encodeWAV(samples, numChannels, sampleRate) {
            const buffer = new ArrayBuffer(44 + samples.length * 2);
            const view = new DataView(buffer);

            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + samples.length * 2, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numChannels * 2, true);
            view.setUint16(32, numChannels * 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, samples.length * 2, true);

            floatTo16BitPCM(view, 44, samples);

            return view;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        function floatTo16BitPCM(output, offset, input) {
            for (let i = 0; i < input.length; i++, offset += 2) {
                const s = Math.max(-1, Math.min(1, input[i]));
                output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
            }
        }
    </script>
</body>
</html>