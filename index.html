<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>The Stupid Saloon Cyborg Band</title>
    <style>
        @font-face {
            font-family: 'IM Fell English';
            src: url('IMFellEnglish.woff2') format('woff2');
            font-weight: normal;
            font-style: normal;
        }

        body,
        #text,
        button,
        .prompt,
        .option,
        .title {
            font-family: 'IM Fell English', serif !important;
        }

        body {
            font-family: "IM Fell English", serif;
            background: black;
            color: white;
            text-align: center;
            padding: 2em;
            font-size: 1.5em;
        }

        img {
            max-width: 90%;
            height: auto;
            margin-bottom: 1em;
        }

        .button {
            display: inline-block;
            background: linear-gradient(to bottom, #3e2f23, #2a1f16);
            border: 1px solid #a57c57;
            border-radius: 4px;
            color: #f4e7d0;
            font-family: 'IM Fell English', serif;
            letter-spacing: 0.5px;
            padding: 10px 16px;
            margin: 1em;
            cursor: pointer;
            box-shadow: inset 0 0 4px #00000088, 0 0 6px #3defff44;
            transition: all 0.2s ease-in-out;
            font-size: 1em;
        }

        .button:hover {
            background: #4c372a;
            border-color: #ffc56f;
            box-shadow: inset 0 0 6px #000000aa, 0 0 10px #00ffe655;
            transform: translateY(-1px);
        }

        .button:active {
            transform: scale(0.97);
            box-shadow: inset 0 0 3px #000000cc, 0 0 4px #ffaa0088;
        }

        .button.waiting {
            animation: pulse 1.2s ease-in-out infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 6px #3defff33;
                background-color: #3e2f23;
            }

            50% {
                box-shadow: 0 0 20px #3defffbb;
                background-color: #4c372a;
            }

            100% {
                box-shadow: 0 0 6px #3defff33;
                background-color: #3e2f23;
            }
        }

        .image-text-container {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            gap: 2em;
            margin-bottom: 1.5em;
            flex-wrap: wrap;
        }
        .image-text-container img {
            max-width: 100%;
            height: auto;
        }
        .text-block {
            max-width: 600px;
            text-align: left;
        }

        @media (max-width: 768px) {
            body {
                font-size: 1.875em; /* 25% bigger than original 1.5em */
            }
            .image-text-container {
                flex-direction: column;
                align-items: center;
                gap: 2.5em;
            }
            .text-block {
                text-align: center;
            }
            .button {
                padding: 12px 20px;
                font-size: 1.25em;
            }
        }

        .fade-in {
            opacity: 0;
            transition: opacity 0.8s ease-in;
        }
        .fade-in.loaded {
            opacity: 1; /* Changed from 0.4 for better visibility */
        }

        .scrolling-container {
            height: 300px;
            overflow: hidden;
            position: relative;
            width: 100%;
            margin: 2em auto;
            border: 1px dashed #555; /* Added for visibility */
        }

        .scrolling-inner {
            position: relative;
            text-align: center;
            white-space: pre-line;
             /* Added to prevent text overflow issues */
            padding: 0 10px;
        }

        .slideshow-container {
            position: absolute; /* Changed from fixed to work within scrolling */
            max-height: 150px; /* Reduced size */
            width: 150px;  /* Reduced size */
            pointer-events: none;
            z-index: 0;
            /* Animation applied dynamically */
        }

        .slideshow-container.left-fixed {
            left: 20px; /* Adjusted position */
            top: 20%;
        }

        .slideshow-container.right {
            right: 20px; /* Adjusted position */
            top: 40%;
        }

        .slideshow-image {
            max-height: 150px; /* Reduced size */
            width: auto;
            opacity: 0;
            transition: opacity 4s ease-in-out;
            border: 1px solid #666; /* Added border */
        }

        .slideshow-image.visible {
            opacity: 0.4;
        }

        @keyframes floatUp { 0% { transform: translateY(0); } 100% { transform: translateY(-15px); } }
        @keyframes floatDown { 0% { transform: translateY(0); } 100% { transform: translateY(15px); } }
        @keyframes floatLeft { 0% { transform: translateX(0); } 100% { transform: translateX(-15px); } }
        @keyframes floatRight { 0% { transform: translateX(0); } 100% { transform: translateX(15px); } }
        @keyframes floatDiagonalLeft { 0% { transform: translate(0, 0); } 100% { transform: translate(-15px, -15px); } }
        @keyframes floatDiagonalRight { 0% { transform: translate(0, 0); } 100% { transform: translate(15px, -15px); } }

        .floatUp { animation: floatUp 6s ease-in-out infinite alternate; }
        .floatDown { animation: floatDown 6s ease-in-out infinite alternate; }
        .floatLeft { animation: floatLeft 6s ease-in-out infinite alternate; }
        .floatRight { animation: floatRight 6s ease-in-out infinite alternate; }
        .floatDiagonalLeft { animation: floatDiagonalLeft 6s ease-in-out infinite alternate; }
        .floatDiagonalRight { animation: floatDiagonalRight 6s ease-in-out infinite alternate; }

        /* Style for the hidden SVG comic template */
        #comicSvgWrapper {
            display: none; /* Keep the template hidden */
            position: absolute;
            left: -9999px; /* Move off-screen */
            top: -9999px;
        }

    </style>
</head>

<body>

    <div id="game">
        <p>Loading story...</p>
    </div>

    <div id="comicSvgWrapper">
        <svg width="800" height="1100" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="background-color: white;">
            <defs>
                <style>
                    .title { font: bold 30px 'IM Fell English', serif; fill: black; text-anchor: middle; }
                    .panel-border { stroke: black; stroke-width: 4px; fill: none; }
                </style>
            </defs>
            <text x="400" y="50" class="title">My Stupid Saloon Adventure!</text>

            <rect x="50" y="80" width="330" height="280" class="panel-border"/>
            <image id="panel1" x="55" y="85" width="320" height="270" xlink:href="" />

            <rect x="420" y="80" width="330" height="280" class="panel-border"/>
            <image id="panel2" x="425" y="85" width="320" height="270" xlink:href="" />

            <rect x="50" y="390" width="330" height="280" class="panel-border"/>
            <image id="panel3" x="55" y="395" width="320" height="270" xlink:href="" />

            <rect x="420" y="390" width="330" height="280" class="panel-border"/>
            <image id="panel4" x="425" y="395" width="320" height="270" xlink:href="" />

            <rect x="50" y="700" width="330" height="280" class="panel-border"/>
            <image id="panel5" x="55" y="705" width="320" height="270" xlink:href="" />

            <rect x="420" y="700" width="330" height="280" class="panel-border"/>
            <image id="panel6" x="425" y="705" width="320" height="270" xlink:href="" />

            <text x="400" y="1050" style="font: 12px sans-serif; text-anchor: middle;">Created with The Stupid Saloon Cyborg Band Generator</text>
        </svg>
    </div>
    <script>
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let buffers = {};
        let currentSource = null;
        let multiAudioSources = {};
        let multiAudioGains = {};
        let currentMultiAudio = null;

        let choiceMade = null;
        let isLoopingScene = false;
        let currentScene = null;
        let storyData = [];
        let visitedImages = []; // Stores URLs of images encountered

        function loadAudio(url) {
            if (buffers[url]) {
                return Promise.resolve(buffers[url]); // Return cached buffer if available
            }
            return fetch(url)
                .then(res => {
                    if (!res.ok) throw new Error(`HTTP error! status: ${res.status} for ${url}`);
                    return res.arrayBuffer();
                 })
                .then(buf => audioContext.decodeAudioData(buf))
                .then(decodedBuffer => {
                     buffers[url] = decodedBuffer; // Cache the buffer
                     return decodedBuffer;
                 })
                 .catch(e => {
                     console.error(`Failed to load or decode audio: ${url}`, e);
                     return null; // Return null on failure
                 });
        }


        async function playAudio(name, loop, onEnded) {
            stopAudio(); // Stop any currently playing audio first
            const buffer = buffers[name];
            if (!buffer) {
                console.warn(`Audio buffer not found or not loaded for: ${name}`);
                if (onEnded) onEnded(); // Call onEnded immediately if no buffer
                return;
            }
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(audioContext.destination);
            source.loop = loop;

            source.onended = () => {
                 // Clean up reference
                 if (currentSource === source) {
                    currentSource = null;
                 }
                 // Remove waiting class from buttons
                 document.querySelectorAll('.button.waiting').forEach(btn => {
                    btn.classList.remove('waiting');
                 });
                 // Call the provided callback
                 if (onEnded) {
                    onEnded();
                 }
            };

            source.start(0);
            currentSource = source;
        }


        function stopAudio() {
            if (currentSource) {
                try {
                    currentSource.onended = null; // Remove listener to prevent callback on manual stop
                    currentSource.stop();
                } catch (e) {
                    // Ignore errors if source already stopped
                }
                currentSource.disconnect();
                currentSource = null;
            }
            stopMultiAudio(); // Also ensure multi-audio is stopped
        }

        function showScene(sceneId) {
            const scene = storyData.find(s => s.id === sceneId || s.name === sceneId);
            if (!scene) {
                document.getElementById("game").innerHTML = `<p>❌ Scene not found: ${sceneId}</p>`;
                return;
            }
            currentScene = scene;
            // Track visited images (only add unique URLs)
            if (scene.image && !visitedImages.includes(scene.image)) {
                visitedImages.push(scene.image);
                console.log("Tracked images:", visitedImages);
            }

            let html = '';

            // --- Image and Text ---
            if (scene.image || scene.text) {
                const cleanText = scene.text ? scene.text.replace(/\[\[.*?\]\]/g, '') : '';
                html += `
                    <div class="image-text-container">
                        ${scene.image ? `<img src="${scene.image}" alt="Scene image" class="fade-in" onload="this.classList.add('loaded')">` : ''}
                        <div class="text-block">
                            ${scene.scrollText === true
                                ? `<div class="scrolling-container">
                                    <div class="slideshow-container left-fixed"><img id="slideshowImage1" class="slideshow-image" src=""></div>
                                    <div class="slideshow-container right"><img id="slideshowImage2" class="slideshow-image" src=""></div>
                                    <div class="scrolling-inner">${cleanText}</div>
                                   </div>`
                                : cleanText}
                        </div>
                    </div>
                `;
            }

            // --- Choices ---
            if (scene.choices && scene.choices.length > 0) {
                scene.choices.forEach(choice => {
                    html += `<div class="button" onclick="handleChoice('${choice.next}')">${choice.label}</div>`;
                });
            }

            // --- Download Comic Button (FIXED PLACEMENT) ---
            // Check if this scene is an ending scene (no choices)
            if (!scene.choices || scene.choices.length === 0) {
                html += `<div class="button" onclick="downloadComic()">📄 Download Your Adventure Comic</div>`;
            }

            // --- Multi Audio Buttons ---
            if (scene.multiAudio && Object.keys(scene.multiAudio).length > 0) {
                const switcherButtons = Object.keys(scene.multiAudio).map(label =>
                    `<button class='button' onclick="switchToTrack('${label}')">Switch to ${label}</button>`
                ).join("");
                html += "<div style='margin-top:1em'>" + switcherButtons + "</div>";
            }


            // --- Update Game Area ---
            document.getElementById("game").innerHTML = html;

            // --- Handle Audio ---
            if (scene.multiAudio && Object.keys(scene.multiAudio).length > 0) {
                isLoopingScene = true; // Multi-audio always loops tracks internally
                playMultiAudio(scene.multiAudio); // Removed onEnded callback here, handled in handleChoice
            } else if (scene.audio) {
                isLoopingScene = scene.loopAudio;
                playAudio(scene.audio, scene.loopAudio, () => {
                    // This callback now only runs if audio finishes *naturally*
                    if (choiceMade) {
                        showScene(choiceMade);
                        choiceMade = null;
                    }
                });
            } else {
                 isLoopingScene = false; // No audio for this scene
                 stopAudio(); // Ensure any previous audio stops
            }

            // --- Handle Scrolling Text / Slideshow ---
            if (scene.scrollText === true) {
                setupScrollingTextAndSlideshow();
            }
        }

        function setupScrollingTextAndSlideshow() {
            const img1 = document.getElementById("slideshowImage1");
            const img2 = document.getElementById("slideshowImage2");

            if (visitedImages.length > 0 && img1 && img2) {
                const floatClasses = ['floatUp', 'floatDown', 'floatLeft', 'floatRight', 'floatDiagonalLeft', 'floatDiagonalRight'];

                function applyRandomFloatClass(img) {
                    img.className = 'slideshow-image'; // Reset classes first
                    const randomClass = floatClasses[Math.floor(Math.random() * floatClasses.length)];
                    img.classList.add(randomClass);
                }

                function randomizePosition(container) {
                   if (container) {
                       const top = Math.floor(Math.random() * 60) + 10; // Adjusted range
                       container.style.top = top + '%';
                   }
                }

                let slideshowIndex = 0;
                let intervalId = setInterval(() => {
                   if (visitedImages.length === 0) return; // Stop if no images

                    const src = visitedImages[slideshowIndex % visitedImages.length];
                    const isEven = slideshowIndex % 2 === 0;

                    if (isEven && img1) {
                        img1.src = src;
                        applyRandomFloatClass(img1);
                        randomizePosition(img1.parentElement);
                        img1.classList.add("visible");
                        if (img2) img2.classList.remove("visible");
                    } else if (img2) {
                        img2.src = src;
                        applyRandomFloatClass(img2);
                        randomizePosition(img2.parentElement);
                        img2.classList.add("visible");
                        if (img1) img1.classList.remove("visible");
                    }
                    slideshowIndex++;
                }, 4000);

                // Clear interval when leaving the scene? Consider adding cleanup logic if needed.
            }

            // Scrolling text setup
            const container = document.querySelector('.scrolling-container');
            const inner = document.querySelector('.scrolling-inner');
            if (container && inner) {
                // Reset scroll position
                inner.style.transition = 'none';
                inner.style.transform = 'translateY(0px)';

                // Calculate distance and duration
                const distance = inner.scrollHeight - container.clientHeight;
                 // Ensure minimum duration even for short text
                const duration = Math.max(10, distance / 30); // Pixels per second

                // Force reflow before applying transition
                void inner.offsetWidth;

                // Start scrolling animation
                 inner.style.transition = `transform ${duration}s linear`;
                 inner.style.transform = `translateY(-${distance}px)`;
            }
        }


        function handleChoice(nextId) {
            const selectedChoice = currentScene.choices.find(c => c.next === nextId);
            choiceMade = nextId; // Store the next scene ID

             // Add waiting class to the clicked button
             const buttons = document.querySelectorAll(".button");
             buttons.forEach(btn => {
                  if (btn.textContent === selectedChoice?.label) {
                      btn.classList.add("waiting");
                  } else {
                      btn.classList.remove("waiting"); // Remove from others
                  }
             });


            if (isLoopingScene) {
                // --- Handling transition FROM looping scenes ---
                if (currentSource) { // If single looping audio is playing
                    currentSource.loop = false; // Stop looping, let it play out
                     // onended callback of playAudio will handle showing the next scene
                } else if (currentMultiAudio) { // If multi-audio is playing
                    // Fade out all tracks smoothly
                    const fadeDuration = 0.5; // seconds
                    for (let label in multiAudioGains) {
                        multiAudioGains[label].gain.setTargetAtTime(0, audioContext.currentTime, fadeDuration / 3); // Faster fade start
                    }
                    // Wait for fade-out, then stop and transition
                    setTimeout(() => {
                        stopMultiAudio();
                        if (choiceMade) { // Check again in case something changed
                           showScene(choiceMade);
                           choiceMade = null;
                        }
                    }, fadeDuration * 1000);
                } else {
                     // Should not happen if isLoopingScene is true, but as fallback:
                     showScene(choiceMade);
                     choiceMade = null;
                }
            } else {
                // --- Handling transition FROM non-looping scenes ---
                // Stop any non-looping audio immediately and go to the next scene
                stopAudio(); // Includes stopping multi-audio just in case
                showScene(choiceMade);
                choiceMade = null;
            }
        }


        function preloadImages(imageUrls) {
            imageUrls.forEach(url => {
                if(url){ // Only preload if URL is not empty
                   const img = new Image();
                   img.src = url;
                }
            });
        }

        async function loadStory() {
            try {
                const res = await fetch("story.json");
                 if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
                storyData = await res.json();

                // --- Preload Images ---
                const imageUrls = storyData
                    .filter(scene => scene.image)
                    .map(scene => scene.image);
                preloadImages(imageUrls);

                // --- Preload Audio ---
                const audioUrlsToLoad = new Set();
                storyData.forEach(scene => {
                    if (scene.audio) audioUrlsToLoad.add(scene.audio);
                    if (scene.multiAudio) {
                        Object.values(scene.multiAudio).forEach(url => audioUrlsToLoad.add(url));
                    }
                });

                const audioLoadPromises = [...audioUrlsToLoad].map(url => loadAudio(url));
                await Promise.all(audioLoadPromises); // Wait for all audio to be fetched and decoded

                // --- Display Start Scene ---
                const startScene = storyData.find(s => s.name === "START");
                if (!startScene) throw new Error("START scene not found in story.json");

                const startText = (startScene.text || 'Welcome adventurer...')
                    .replace(/\n/g, '<br>')
                    .replace(/\[\[.*?\]\]/g, ''); // Remove choice markers for initial display

                document.getElementById("game").innerHTML = `
                    <div class="image-text-container">
                        ${startScene.image ? `<img src="${startScene.image}" alt="Start image" class="fade-in" onload="this.classList.add('loaded')">` : ''}
                        <div class="text-block">${startText}</div>
                    </div>
                    <div class="button" onclick="startScene()">BEGIN YOUR ADVENTURE</div>
                `;
            } catch (err) {
                document.getElementById("game").innerHTML = `<p>❌ Failed to load or parse story.json<br>${err.message}</p>`;
                console.error(err);
            }
        }

        function startScene() {
            // Find the scene linked from the START node's first choice
            const startData = storyData.find(s => s.name === "START");
            const firstSceneId = startData?.choices?.[0]?.next || "scene1"; // Fallback needed?
            showScene(firstSceneId);
        }

        // --- Multi Audio Functions ---

        async function playMultiAudio(multiAudioMap) {
            stopAudio(); // Stop regular audio first
            stopMultiAudio(); // Stop any previous multi-audio

            multiAudioSources = {};
            multiAudioGains = {};
            currentMultiAudio = null; // Reset flag

            const labels = Object.keys(multiAudioMap || {});
            if (labels.length === 0) return;

            const loadPromises = labels.map(label => {
                 const url = multiAudioMap[label];
                 // Use already loaded buffers if possible
                 if (buffers[url]) {
                     return Promise.resolve({ label, buffer: buffers[url] });
                 } else {
                     // Attempt to load if not already loaded (should be preloaded, but as fallback)
                     console.warn(`Multi-audio track not preloaded, loading now: ${url}`);
                     return loadAudio(url).then(buffer => ({ label, buffer }));
                 }
            });


            try {
                const results = await Promise.all(loadPromises);
                 const now = audioContext.currentTime;

                results.forEach(({ label, buffer }) => {
                     if (!buffer) {
                         console.error(`Buffer missing for multi-audio track: ${label}`);
                         return; // Skip this track if buffer failed to load
                     }
                    const source = audioContext.createBufferSource();
                    source.buffer = buffer;
                    source.loop = true;

                    const gainNode = audioContext.createGain();
                    gainNode.gain.setValueAtTime(0, now); // Start silent

                    source.connect(gainNode).connect(audioContext.destination);
                    source.start(now); // Start all sources simultaneously

                    multiAudioSources[label] = source;
                    multiAudioGains[label] = gainNode;
                });

                 // Fade in the first track
                 const firstTrackLabel = labels[0];
                 if (multiAudioGains[firstTrackLabel]) {
                    multiAudioGains[firstTrackLabel].gain.setTargetAtTime(1, now, 0.05); // Quick fade-in
                 }

                 currentMultiAudio = true; // Set flag indicating multi-audio is active

            } catch (error) {
                 console.error("Error setting up multi-audio:", error);
                 stopMultiAudio(); // Clean up on error
            }
        }


        function stopMultiAudio() {
            for (let label in multiAudioSources) {
                try {
                    multiAudioSources[label].stop();
                    multiAudioSources[label].disconnect();
                } catch (e) {}
            }
            multiAudioSources = {};
            multiAudioGains = {};
            currentMultiAudio = null;
        }

        function switchToTrack(label) {
            if (!currentMultiAudio || !multiAudioGains[label]) return; // Only switch if multi-audio is active
            const now = audioContext.currentTime;
            const fadeTime = 0.1; // Short crossfade
            for (let l in multiAudioGains) {
                multiAudioGains[l].gain.setTargetAtTime(l === label ? 1 : 0, now, fadeTime);
            }
        }

        // --- Download Comic Function ---
        window.downloadComic = async function downloadComic() {
            console.log("Attempting to download comic...");
            const svgWrapper = document.getElementById("comicSvgWrapper");
            const svgElement = svgWrapper ? svgWrapper.querySelector("svg") : null;

            if (!svgElement) {
                console.error("SVG comic template element (#comicSvgWrapper svg) not found!");
                alert("Sorry, the comic template SVG is missing from the page. Cannot generate PDF.");
                return;
            }

            const panels = Array.from(svgElement.querySelectorAll("image[id^='panel']"));
            console.log(`Found ${panels.length} panels in SVG template.`);
            console.log("Visited images for comic:", visitedImages);


            // Populate SVG panels with visited images
            panels.forEach((panel, i) => {
                const panelId = panel.getAttribute("id");
                if (visitedImages[i]) {
                    panel.setAttribute("xlink:href", visitedImages[i]); // Use xlink:href for <image> in SVG 1.1
                    console.log(`Setting ${panelId} href to: ${visitedImages[i]}`);
                } else {
                    // Optionally clear or set a default placeholder if image is missing
                    panel.removeAttribute("xlink:href");
                    console.log(`No image for ${panelId} (index ${i})`);
                     // Example: Fill with grey if missing
                     // const rect = panel.previousElementSibling; // Assuming rect precedes image
                     // if (rect && rect.tagName.toLowerCase() === 'rect') {
                     //    rect.setAttribute('fill', '#cccccc');
                     // }
                }
            });

             // Get the updated SVG markup as a string
             // Need to handle xlink:href correctly for Canvg
             const svgString = new XMLSerializer().serializeToString(svgElement)
                                            .replace(/xmlns:xlink=/g, 'xmlns=') // Canvg workaround
                                            .replace(/xlink:href=/g, 'href='); // Canvg expects href

            const canvas = document.createElement("canvas");
            // Use SVG dimensions for canvas to maintain aspect ratio initially
            const svgWidth = svgElement.getAttribute("width");
            const svgHeight = svgElement.getAttribute("height");
            canvas.width = svgWidth ? parseInt(svgWidth) : 800;   // Default fallback size
            canvas.height = svgHeight ? parseInt(svgHeight) : 1100; // Default fallback size
            const ctx = canvas.getContext("2d");


            try {
                 console.log("Rendering SVG to Canvas with Canvg...");
                 // Ensure Canvg is loaded (Check network tab or script tags)
                 if (typeof Canvg === 'undefined') {
                      throw new Error("Canvg library is not loaded.");
                 }
                 const v = await Canvg.from(ctx, svgString);
                 await v.render();
                 console.log("SVG rendering complete.");

                 const imgData = canvas.toDataURL("image/png");
                 console.log("Canvas data URL generated.");

                 // Ensure PDFLib is loaded
                 if (typeof PDFLib === 'undefined') {
                      throw new Error("pdf-lib library is not loaded.");
                 }
                 const pdfDoc = await PDFLib.PDFDocument.create();
                 const pngImage = await pdfDoc.embedPng(imgData);

                 // Add page matching the canvas/image dimensions
                 const page = pdfDoc.addPage([pngImage.width, pngImage.height]);
                 page.drawImage(pngImage, {
                    x: 0,
                    y: 0,
                    width: pngImage.width,
                    height: pngImage.height,
                 });
                 console.log("PDF page created and image drawn.");

                 const pdfBytes = await pdfDoc.save();
                 console.log("PDF saved to bytes.");

                 const blob = new Blob([pdfBytes], { type: "application/pdf" });
                 const link = document.createElement("a");
                 link.href = URL.createObjectURL(blob);
                 link.download = "your-adventure-comic.pdf";
                 link.click();
                 URL.revokeObjectURL(link.href); // Clean up blob URL
                 console.log("Download initiated.");

            } catch (error) {
                console.error("Error generating or downloading PDF comic:", error);
                alert(`Failed to generate comic PDF. Error: ${error.message}`);
            }
        };

        // --- Load External Libraries & Start ---
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.body.appendChild(script);
            });
        }

        async function initialize() {
           try {
                console.log("Loading libraries...");
                await Promise.all([
                     loadScript("https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"),
                     loadScript("https://cdn.jsdelivr.net/npm/canvg@4.0.1/lib/umd.min.js") // Use specific version of Canvg v4
                ]);
                console.log("Libraries loaded.");
                console.log("Loading story...");
                await loadStory(); // Load story data after libraries are ready
                console.log("Story loaded. Initialization complete.");
           } catch (error) {
               console.error("Failed to load libraries or story:", error);
               document.getElementById("game").innerHTML = `<p>❌ Failed to initialize game. Check console for errors.</p>`;
           }
        }

        // Start the game initialization process
        initialize();

    </script>

</body>
</html>